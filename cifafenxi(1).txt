#include<iostream>#include<bits/stdc++.h>#include<vector>#include<string>#include<sstream>using namespace std;class TokenNode{public:    string type;//类别    string seq;//序号    string token;//词    TokenNode(string A,string B,string C)    {        type=A;        seq=B;        token=C;    }   void  printout()    {        cout<<"<"<<type<<","<<seq<<","<<token<<">"<<endl;    }};vector<TokenNode> TokenAll;extern char IDElist[100][20]; //标识符表iextern char SINlist[100]; //字符表textern char STRlist[100][20];  //字符串表Sextern char CONlist[100][20]; //常数表Cextern char RESlist[50][20];//关键字表kextern char DELlist[50][10];//界运算符表pchar RESlist[50][20] =//关键字表k{    "int","main","void","if","else","char","float","double","for","enum","const"};char DELlist[50][10]=//界运算符表p{    "+","-","*","/","<","<=",">",">=","=","==",    "!=",";","(",")","^",",","\"","\'","&","&&",    "|","||","%","~","<<",">>","[","]","{","}",    "\?",":","!","&&"};char IDElist[100][20]= {""}; //标识符表ichar SINlist[100]= {""}; //字符表tchar STRlist[100][20]= {""}; //字符串表Schar CONlist[100][20]= {""}; //常数表CFILE *fp1;//文件指针int ctcount=0;//字符表ct指针int ccount=0;//常数表C指针int scount=0; //字符串表S指针int tcount=0;//标识符表i指针char ReProject[9999];//输入的源程序存放处int RESsearch(char reserve[][20],char s[])//查找保留字，若成功查找，则返回种别码，否则返回-1，代表查找不成功，即为标识符{    for(int i=0; reserve[i][0]!='\0'; i++)    {        if(strcmp(reserve[i],s)==0)            return i+1;    }    return -1;}int SINsearch(char reserve[],char s)//查找字符表，若成功查找，则返回种别码，否则返回-1，代表查找不成功{    for(int i=0; reserve[i]!='\0'; i++)    {        if(reserve[i]==s)            return i+1;    }    return -1;}bool ifletter(char letter)//如果是字母或_则返回true，否则返回false{    if(letter>='a'&&letter<='z'||letter>='A'&&letter<='Z'||letter=='_')        return true;    else        return false;}bool ifdigit(char digit)//如果是数字则返回true，否则返回false{    if(digit>='0'&&digit<='9')        return true;    else        return false;}void filterResource(char r[],int pProject)//过滤掉原始字符数组r[]中的注释、换行符、水平制表符、垂直制表符、回车符，并放回r[]中{    char tempString[10000];    int count=0;    for(int i=0; i<=pProject; i++)    {        if(r[i]=='/'&&r[i+1]=='/')            while(r[i]!='\n')                i++;        if(r[i]=='/'&&r[i+1]=='*')        {            i+=2;            while(r[i]!='*'||r[i+1]!='/')            {                i++;                if(r[i]=='#')                {                    cout<<"注释出错"<<endl;                    exit(0);                }            }            i+=2;        }        if(r[i]!='\n'&&r[i]!='\t'&&r[i]!='\v'&&r[i]!='\r')        {            tempString[count++]=r[i];        }    }    tempString[count]='\0';    strcpy(r,tempString);}string int_str(int &k)//将数字转换成字符串{    string s;    stringstream ss;    ss<<k;    return ss.str();}void saomiao(int &syn,char ReProject[],char token[],int &pProject)//扫描源程序{    int i,count=0;//count用来做token指示，收集有用字符    char ch;    ch=ReProject[pProject];    while(ch==' ')    {        pProject++;        ch=ReProject[pProject];    }    for(i=0; i<20; i++)    {        token[i]='\0';//收集前先清零    }    if(ifletter(ReProject[pProject]))    {        token[count++]=ReProject[pProject];        pProject++;        while(ifletter(ReProject[pProject])||ifdigit(ReProject[pProject]))        {            token[count++]=ReProject[pProject];            pProject++;        }        token[count]='\0';        syn=RESsearch(RESlist,token);//判断是否为关键字        if(syn!=-1)        {            TokenNode b("KT",int_str(syn),RESlist[syn-1]);            TokenAll.push_back(b);            fprintf(fp1, "{KT   ,   %d   ,%s }\n", syn,RESlist[syn-1]);        }        if(syn==-1)        {            syn=RESsearch(IDElist,token);//搜索标识符表            if(syn==-1)            {                strcpy(IDElist[tcount++],token);                syn=tcount;            }            TokenNode b("iT",int_str(syn),IDElist[syn-1]);            TokenAll.push_back(b);            fprintf(fp1, "{iT   ,   %d   ,%s }\n", syn,IDElist[syn-1]);        }    }    else if(ifdigit(ReProject[pProject]))    {        while(ifdigit(ReProject[pProject])||ReProject[pProject]=='.')        {            token[count++]=ReProject[pProject];            pProject++;        }        token[count]='\0';        syn=RESsearch(CONlist,token);        if(syn==-1)        {            strcpy(CONlist[ccount++],token);            syn=ccount;        }        TokenNode b("CT",int_str(syn),CONlist[syn-1]);         TokenAll.push_back(b);        fprintf(fp1, "{CT   ,   %d   ,%s }\n", syn,CONlist[syn-1]);    }    else if(ReProject[pProject]=='\'')    {        pProject++;        if(ifletter(ReProject[pProject]))        {            pProject++;            if(ReProject[pProject]=='\'')            {                pProject--;                syn=SINsearch(SINlist,ReProject[pProject]);                if(syn==-1)                {                    SINlist[ctcount++]=ReProject[pProject];                    syn=ctcount;                }            }        }         string A;        A +=SINlist[syn-1];        TokenNode b("cT",int_str(syn),A);        TokenAll.push_back(b);        fprintf(fp1, "{cT   ,   %d  , %c }\n", syn,SINlist[syn-1]);        pProject+=2;    }    else if(ReProject[pProject]=='"')    {        pProject++;        while(ReProject[pProject]!='"')        {            token[count++]=ReProject[pProject];            pProject++;        }        token[count]='\0';        syn=RESsearch(STRlist,token);        if(syn==-1)        {            strcpy(STRlist[scount++],token);            syn=scount;        }        TokenNode b("sT",int_str(syn),STRlist[syn-1]);           TokenAll.push_back(b);        fprintf(fp1, "{sT   ,   %d   ,%s }\n", syn,STRlist[syn-1]);        pProject++;    }    else if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == ';' || ch == '(' || ch == ')' //若为运算符或者界符，查表得到结果             || ch == '^'|| ch == ',' || ch == '~' || ch == '%' || ch == '['             || ch == ']' || ch == '{' || ch == '}' || ch == '\?' || ch == ':')    {        token[0] = ReProject[pProject];        token[1] = '\0';        for (i = 0; i<36; i++)        {            if (strcmp(token, DELlist[i]) == 0)            {                syn = i+1;                break;            }        }        TokenNode b("PT",int_str(syn),DELlist[syn-1]);        TokenAll.push_back(b);        fprintf(fp1, "{PT   ,   %d   ,%s }\n", syn,DELlist[syn-1]);        pProject++;    }    else if(ReProject[pProject]=='<')//可能为<,<=,<<    {        pProject++;        if(ReProject[pProject]=='=') syn=6;        else if(ReProject[pProject]=='<')            syn=26;        else        {            pProject--;            syn=5;        }        TokenNode b("PT",int_str(syn),DELlist[syn-1]);        TokenAll.push_back(b);        fprintf(fp1, "{PT   ,   %d   ,%s }\n", syn,DELlist[syn-1]);        pProject++;    }    else if(ReProject[pProject]=='>')//可能为>,>=,>>    {        pProject++;        if(ReProject[pProject]=='=') syn=8;        else if(ReProject[pProject]=='>') syn=27;        else        {            pProject--;            syn=7;        }       TokenNode b("PT",int_str(syn),DELlist[syn-1]);        TokenAll.push_back(b);        fprintf(fp1, "{PT   ,   %d   ,%s }\n", syn,DELlist[syn-1]);        pProject++;    }    else if(ReProject[pProject]=='=')//可能为=,==    {        pProject++;        if(ReProject[pProject]=='=') syn=10;        else        {            pProject--;            syn=9;        }        TokenNode b("PT",int_str(syn),DELlist[syn-1]);        TokenAll.push_back(b);        fprintf(fp1, "{PT   ,   %d   ,%s }\n", syn,DELlist[syn-1]);        pProject++;    }    else if(ReProject[pProject]=='!')//可能为 !,!=    {        pProject++;        if(ReProject[pProject]=='=') syn=11;        else        {            pProject--;            syn=36;        }       TokenNode b("PT",int_str(syn),DELlist[syn-1]);        TokenAll.push_back(b);        fprintf(fp1, "{PT   ,   %d   ,%s }\n", syn,DELlist[syn-1]);        pProject++;    }    else if(ReProject[pProject]=='&')//可能为&,&&    {        pProject++;        if(ReProject[pProject]=='&') syn=21;        else        {            pProject--;            syn=20;        }        TokenNode b("PT",int_str(syn),DELlist[syn-1]);        TokenAll.push_back(b);        fprintf(fp1, "{PT   ,   %d   ,%s }\n", syn,DELlist[syn-1]);        pProject++;    }    else if(ReProject[pProject]=='|')//可能为|,||    {        pProject++;        if(ReProject[pProject]=='|') syn=23;        else        {            pProject--;            syn=22;        }        TokenNode b("PT",int_str(syn),DELlist[syn-1]);        TokenAll.push_back(b);        fprintf(fp1, "{PT   ,   %d   ,%s }\n", syn,DELlist[syn-1]);        pProject++;    }    else if(ReProject[pProject]=='#')    {        syn=0;        TokenNode m("f","1","#");        TokenAll.push_back(m);    }    else    {        cout<<"error: no exist "<<ReProject[pProject]<<endl;        exit(0);    }}void print()//输出token序列{    for(int i=0; i<TokenAll.size(); i++)        TokenAll[i].printout();}void cifafenxi()//词法分析器{    char token[20]= {0}; //每次扫描存储已扫描的结果。    int syn=-1;//syn即为种别码，‘#’的syn为0    int pProject = 0;//源程序指针    FILE *fp;    //打开源文件读数据    if((fp=fopen("input.txt","r"))==NULL)    {        cout<<"can not open";        exit(0);    }    ReProject[pProject]=fgetc(fp);    while(ReProject[pProject]!='#')//把源文件中内容读入ReProject[]    {        pProject++;        ReProject[pProject]=fgetc(fp);    }    ReProject[++pProject]='\0';    fclose(fp);    cout<<"文件内容"<<endl;    cout<<ReProject<<endl;    filterResource(ReProject, pProject);//过滤    //向目标文件写入token序列    if((fp1=fopen("output.txt","w"))==NULL)    {        cout<<"can not open";        exit(0);    }    pProject=0;    while(syn!=0)    {        saomiao(syn,ReProject,token,pProject);    }    cout<<endl<<"token序列："<<endl;    print();    fclose(fp1);}int main(){    cifafenxi();    return 0;}